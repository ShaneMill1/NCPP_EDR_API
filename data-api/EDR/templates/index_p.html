<!DOCTYPE html>
<meta charset="UTF-8">
<html lang="en">
<head>
    <title>EDR-API Query Tool</title>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css">
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet-coverage@0.7/leaflet-coverage.css">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.8.0/d3.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.6.12/c3.min.js"></script>


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.1/mini-default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.min.js"></script>
    <script src="{{ config['server']['url'] }}/static/js/covutils.src.js"></script>
    <script src="{{ config['server']['url'] }}/static/js/leaflet-coverage.src.js"></script>
    <script src="https://unpkg.com/leaflet-coverage@0.7/leaflet-coverage.min.js"></script>    
    <script src="https://cdn.jsdelivr.net/covjson-reader/0.16/covjson-reader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wicket/1.3.4/wicket.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw-src.css">
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet-coverage@0.7/leaflet-coverage.css">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css">
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet-coverage@0.7/leaflet-coverage.css">


<!-- Contouring packages caused issues with the position graphing
<script src="https://d3js.org/d3-array.v2.min.js"></script>
<script src="https://d3js.org/d3-contour.v2.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>
 
<script src="https://unpkg.com/d3-array@1"></script>
<script src="https://unpkg.com/d3-contour@1"></script>
<script src="https://unpkg.com/d3-collection@1"></script>
<script src="https://unpkg.com/d3-color@1"></script>
<script src="https://unpkg.com/d3-dispatch@1"></script>
<script src="https://unpkg.com/d3-geo@1"></script>
<script src="https://unpkg.com/d3-geo-projection@2"></script>
<script src="https://unpkg.com/d3-interpolate@1"></script>
<script src="https://unpkg.com/d3-request@1"></script>
<script src="https://unpkg.com/d3-selection@1"></script>
<script src="https://unpkg.com/d3-scale@1"></script>
<script src="https://unpkg.com/geotiff@0.4/dist/geotiff.browserify.min.js"></script>
--> 


    <style>
        html,body,#map,.container
        {
            width: 100%;
            height: 100%;
        }
        #trow
        {
            width: 100%;
            height: 8%;
        }
        #qrow
        {
            width: 100%;
            height: 85%;
        }
        #query-view
        {
            width: 100%;
            height: 100%;
        }
        #urow
        {
            padding-top: 50px;
            width: 100%;
            height: 7%;
        }
        #frow
        {
            width:  100%;
            height: 100%;
            overflow-y: scroll;   
        }
        #dcontainer {
            width: 100%;
            height: 85%;
        }
        #d2container {
            width: calc(100% / 2);
            height: 100%;
            padding: 0;
            margin: 0;
            float: left;
        }
        #formfields
        {
            width: 100%;
            height: 85%;
        }   
        #brow
        {
            width: 100%;
            height: 10%;
        }
        #pnames
        {
            overflow-y: scroll;
            min-height: 25%;  
            max-height: 40%;   
        }

.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {
        max-height: 15px;
        max-width: 15px;
	}


/* Navbar container */
.navbar {
  overflow: hidden;
  background-color: #333;
  font-family: Arial;
}


/* Links inside the navbar */
.navbar a {
  float: left;
  font-size: 16px;
  color: white;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

/* The dropdown container */
.dropdown {
  float: left;
  overflow: hidden;
}

/* Dropdown button */
.dropdown .dropbtn {
  font-size: 16px;
  border: none;
  outline: none;
  color: white;
  padding: 14px 16px;
  background-color: inherit;
  font-family: inherit; /* Important for vertical align on mobile phones */
  margin: 0; /* Important for vertical align on mobile phones */
}

/* Add a red background color to navbar links on hover */
.navbar a:hover, .dropdown:hover .dropbtn {
  background-color: red;
}

/* Dropdown content (hidden by default) */
.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 999999;
}

/* Links inside the dropdown */
.dropdown-content a {
  float: none;
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
  text-align: left;
}

/* Add a grey background color to dropdown links on hover */
.dropdown-content a:hover {
  background-color: #ddd;
}

/* Show the dropdown menu on hover */
.dropdown:hover .dropdown-content {
  display: block;
}

/* testing */

/* Popup box BEGIN */
.hover_bkgr_fricc_base_layers{
    background:rgba(0,0,0,.4);
    cursor:pointer;
    display:none;
    height:100%;
    position:fixed;
    text-align:center;
    top:0;
    width:100%;
    z-index:10000;
}
.hover_bkgr_fricc_base_layers .helper_base_layers{
    display:inline-block;
    height:100%;
    vertical-align:middle;
}
.hover_bkgr_fricc_base_layers > div {
    background-color: #fff;
    box-shadow: 10px 10px 60px #555;
    display: inline-block;
    height: auto;
    max-width: 551px;
    min-height: 100px;
    vertical-align: middle;
    width: 60%;
    position: relative;
    border-radius: 8px;
    padding: 15px 5%;
}
.hover_bkgr_fricc_transparency{
    background:rgba(0,0,0,.4);
    cursor:pointer;
    display:none;
    height:100%;
    position:fixed;
    text-align:center;
    top:0;
    width:100%;
    z-index:10000;
}
.hover_bkgr_fricc_contour{
    background:rgba(0,0,0,.4);
    cursor:pointer;
    display:none;
    height:100%;
    position:fixed;
    text-align:center;
    top:0;
    width:100%;
    z-index:10000;
}


.hover_bkgr_fricc_transparency .helper_transparency{
    display:inline-block;
    height:100%;
    vertical-align:middle;
}

.hover_bkgr_fricc_contour .helper_contour{
    display:inline-block;
    height:100%;
    vertical-align:middle;
}

.hover_bkgr_fricc_transparency > div {
    background-color: #fff;
    box-shadow: 10px 10px 60px #555;
    display: inline-block;
    height: auto;
    max-width: 551px;
    min-height: 100px;
    vertical-align: middle;
    width: 60%;
    position: relative;
    border-radius: 8px;
    padding: 15px 5%;
}

.hover_bkgr_fricc_contour > div {
    background-color: #fff;
    box-shadow: 10px 10px 60px #555;
    display: inline-block;
    height: auto;
    max-width: 551px;
    min-height: 100px;
    vertical-align: middle;
    width: 60%;
    position: relative;
    border-radius: 8px;
    padding: 15px 5%;
}

.popupCloseButton_base_layers {
    background-color: #fff;
    border: 3px solid #999;
    border-radius: 50px;
    cursor: pointer;
    display: inline-block;
    font-family: arial;
    font-weight: bold;
    position: absolute;
    top: -20px;
    right: -20px;
    font-size: 25px;
    line-height: 30px;
    width: 30px;
    height: 30px;
    text-align: center;
}
.popupCloseButton_base_layers:hover {
    background-color: #ccc;
}
.trigger_popup_fricc_base_layers {
  font-size: 16px;
  border: none;
  outline: none;
  color: white;
  padding: 14px 16px;
  background-color: inherit;
  font-family: inherit; /* Important for vertical align on mobile phones */
  margin: 0; /* Important for vertical align on mobile phones */
}

.popupCloseButton_transparency {
    background-color: #fff;
    border: 3px solid #999;
    border-radius: 50px;
    cursor: pointer;
    display: inline-block;
    font-family: arial;
    font-weight: bold;
    position: absolute;
    top: -20px;
    right: -20px;
    font-size: 25px;
    line-height: 30px;
    width: 30px;
    height: 30px;
    text-align: center;
}

.popupCloseButton_contour {
    background-color: #fff;
    border: 3px solid #999;
    border-radius: 50px;
    cursor: pointer;
    display: inline-block;
    font-family: arial;
    font-weight: bold;
    position: absolute;
    top: -20px;
    right: -20px;
    font-size: 25px;
    line-height: 30px;
    width: 30px;
    height: 30px;
    text-align: center;
}
.popupCloseButton_transparency:hover {
    background-color: #ccc;
}

.popupCloseButton_contour:hover {
    background-color: #ccc;
}

.trigger_popup_fricc_transparency {
  font-size: 16px;
  border: none;
  outline: none;
  color: white;
  padding: 14px 16px;
  background-color: inherit;
  font-family: inherit; /* Important for vertical align on mobile phones */
  margin: 0; /* Important for vertical align on mobile phones */
}

.trigger_popup_fricc_contour {
  font-size: 16px;
  border: none;
  outline: none;
  color: white;
  padding: 14px 16px;
  background-color: inherit;
  font-family: inherit; /* Important for vertical align on mobile phones */
  margin: 0; /* Important for vertical align on mobile phones */
}




/* Popup box BEGIN */


/* The switch - the box around the slider */
.switch {
  position: relative;
  display: inline-block;
  width: 30px;
  height: 20px;
}

/* Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* The slider */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 20px;
  width: 20px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(20px);
  -ms-transform: translateX(20px);
  transform: translateX(20px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 20px;
}

.slider.round:before {
  border-radius: 50%;
}

/* transparency slider --------------------- */

.tslidecontainer {
  width: 100%; /* Width of the outside container */
}

/* The slider itself */
.tslider {
  -webkit-appearance: none;  /* Override default CSS styles */
  appearance: none;
  width: 100%; /* Full-width */
  height: 25px; /* Specified height */
  background: #d3d3d3; /* Grey background */
  outline: none; /* Remove outline */
  opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
  -webkit-transition: .2s; /* 0.2 seconds transition on hover */
  transition: opacity .2s;
}

/* Mouse-over effects */
.tslider:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.tslider::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  appearance: none;
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}

.tslider::-moz-range-thumb {
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}



</style>
</head>
<body>

<div class="hover_bkgr_fricc_base_layers">
    <span class="helper_base_layers"></span>
    <div>
        <div class="popupCloseButton_base_layers">&times;</div>
        <div><b>Base Layer Selection:</b><br>
           <div>OpenStreetMap: 
              <label class="switch">
                <input type="checkbox" name='OpenStreetMap' onclick='base_layer_action(this.checked,this.name);'>
                <span class="slider"></span>
              </label>
           </div><br>
           <div>Land/Sea Borders:
              <label class="switch">
                <input type="checkbox" name='land_sea_borders' onclick='base_layer_action(this.checked,this.name);'>
                <span class="slider"></span>
              </label>
           </div><br>
        </div>
    </div>
</div>


<div class="hover_bkgr_fricc_transparency">
    <span class="helper_transparency"></span>
    <div>
        <div class="popupCloseButton_transparency">&times;</div>
        <div><b>Data Layer Opacity:</b><br><br>
           <div class="tslidecontainer">
             <input type="range" min="1" max="100" value="50" class="tslider" id="myRange" onchange="updateOpacity(this.value)">
           </div>
        </div>
        <div id="myRange"></div>
    </div>
</div>

<div class="container">
  <div class="navbar">
     <a href="/OGC-EDR-API">Home
      <i class="fas fa-home"></i>
     </a>
     <div class="dropdown">
       <button class="dropbtn">Palette
         <i class="fas fa-palette"></i>
       <select id='palette_vals' class="dropdown-content" onclick="set_palette(this.value);">
       </select>
       </button>
     </div>
     <div class="dropdown">
       <button class="trigger_popup_fricc_transparency">Opacity
         <i class="fas fa-fill"></i>
       </button>
     </div>
     <div class="dropdown">
       <button class="trigger_popup_fricc_base_layers">Base Layers
         <i class="far fa-map"></i>
       </button>
     </div>
     <div class="dropdown">
       <button  class="trigger_popup_fricc_contour" onclick="contourAction()">Contour
         <i class="fas fa-pencil-ruler"></i>
       </button>
     </div>
  </div>
        <div class="row" id="title-row">
            <div class="col-sm-10">
                <h2 id="col_title"></h2>
            </div>
        </div>
        <div id="qrow" class="row" >    
            <div class="col-sm-8" id="query-view" >

            <img style="display:none" src="https://i.imgur.com/351kRoj.gif" alt="loading..." id="loading_wheel" />
            <div id='map'></div>
            </div>
            <div class="col-sm-4" id="query-view">
                <div  class="float-container" id="dcontainer">
                    <div id="frow">
                    <legend id="formlegend">Point query</legend>
                    <div id="formfields">
                    </div>
                    </div>
                    <div id="brow">
                        <button id='get_data' class="tertiary" onclick="getData();">Get Data</button>
                    </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="urow" class="row" id="url-row">
            <div class="col-sm-1" onclick="copyToClipboard();">
                <span class="tooltip" aria-label="Copy Query URL to clipboard" style="left: 50%;">
                   <svg class="octicon octicon-clippy" viewBox="0 0 14 16" version="1.1" width="28" height="32" aria-hidden="true"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"></path></svg>                   
                </span>
            </div>
            <br>
            <div class="col-sm-11">
                <input id="qurl" style="width:100%"></input>
            </div>
        </div>        
    </div>
</body>
<script>

    function base_layer_action(checked,layer_name){
       if (checked == false){
          for (layer_find in map._layers){
             map_layer_id=map._layers[layer_find].id;
             if (map_layer_id == layer_name){
                layer_to_delete=map._layers[layer_find];
                map.removeLayer(layer_to_delete); 
             }
          }
       }
       if (checked == true) {
          layer_check=true;
          if (layer_name=='OpenStreetMap' && layer_check==true){
             layer_to_add = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');
             layer_to_add.id='OpenStreetMap';
             layer_to_add.addTo(map);
          }
          if (layer_name=='land_sea_borders' && layer_check==true){
             add_country_borders();
          }
       }
    }


$(window).on('load',function () {
    $(".trigger_popup_fricc_base_layers").click(function(){
       $('.hover_bkgr_fricc_base_layers').show();
    });
    $('.hover_bkgr_fricc_base_layers').click(function(){
        $('.hover_bkgr_fricc_base_layers').hide();
    });
    $('.popupCloseButton_base_layers').click(function(){
        $('.hover_bkgr_fricc_base_layers').hide();
    });
});

$(window).on('load',function () {
    $(".trigger_popup_fricc_transparency").click(function(){
       $('.hover_bkgr_fricc_transparency').show();
    });
    $('.hover_bkgr_fricc_transparency').click(function(){
        $('.hover_bkgr_fricc_transparency').hide();
    });
    $('.popupCloseButton_transparency').click(function(){
        $('.hover_bkgr_fricc_transparency').hide();
    });
});

$(window).on('load',function () {
    $(".trigger_popup_fricc_contour").click(function(){
       $('.hover_bkgr_fricc_contour').show();
    });
    $('.hover_bkgr_fricc_contour').click(function(){
        $('.hover_bkgr_fricc_contour').hide();
    });
    $('.popupCloseButton_contour').click(function(){
        $('.hover_bkgr_fricc_contour').hide();
    });
});


function updateOpacity(opacity_value) {
   for (layer_find in map._layers){
      map_layer_id=map._layers[layer_find].id;
      if (map_layer_id == 'data_layer'){
         layer_transparency=map._layers[layer_find];     
         opacity=opacity_value/100;
         layer_transparency.setOpacity(opacity).redraw();
         console.log(opacity);   
         console.log(layer_transparency); 
      }
   }
}   


    let zoom_level = 1.5;
    let urlparts = unescape(location.pathname).split("/");
    let urllen = urlparts.length;
    let collection = urlparts[urllen - 2];
    document.getElementById('col_title').innerText =  urlparts[urllen - 2] + " instance of " + "Collection: " + urlparts[urllen - 3];
    let ispoint = false;
    let ispolygon = false;
    let iscube = false;
    let istrajectory = false;
    let iscorridor = false;
    let map_center = [20,0]
    let httpRequest;
    let capsJSON;

    let errmsg = ""

    function copyToClipboard() {
        let copyText = document.querySelector("#qurl");
        copyText.select();
        document.execCommand("copy");
    }



    function getData() {
        if (urlparts[urllen-1] == "position") {
            getPointQuery();
        } else if (urlparts[urllen-1] == "area" || urlparts[urllen-1] == "cube") {
            getPolygonQuery()
        }
        else if (urlparts[urllen-1] == "trajectory") {
            getTrajectoryQuery()
        }
        else if (urlparts[urllen-1] == "corridor") {
            getCorridorQuery()
        }
    }

    function createFormGroup(labelId,label,impType,col1,col2,name) {

        html_block = '<div class="row"><div class="col-sm-'+col1+'"><label>'+label+'</label></div>';
        html_block += '<div class="col-sm-'+col2+'"><input type="'+impType+'" id="'+labelId+'" name="'+name+'" /></div></div>';
        return html_block;                                   
    }

    function createTimeGroup(timeValues) {
        let html_block = '<div class="row"><div class="container"><div class="row">';
        html_block += '<div class="col-sm-6"><label>Start time</label></div>';
        html_block += '<div class="col-sm-6"><label>End time</label></div></div>';
        html_block += '<div class="row"><div class="col-sm-6">';
        let times_block = '';
        for (let timeIndex in timeValues) {
            times_block += '<option>'+timeValues[timeIndex]+'</option>';
        }
        html_block += '<select type="text" id="starttime">' + times_block + '</select>'
        html_block += '</div><div class="col-sm-6">';
        html_block += '<select type="text" id="endtime">' + times_block + '</select>'
        html_block += '</div></div></div></div>'
        return html_block;
    }

    function createTimeGroupTrajectory(timeValues) {
        let html_block = '<div class="row"><div class="container"><div class="row">';
        html_block += '<div class="col-sm-6"><label>Time Selection</label></div>';
        html_block += '<div class="row"><div class="col-sm-6">';
        let times_block = '';
        for (let timeIndex in timeValues) {
            times_block += '<option>'+timeValues[timeIndex]+'</option>';
        }
        html_block += '<select type="text" id="starttime">' + times_block + '</select>'
        html_block += '</div>';
        //html_block += '</div><div class="col-sm-6">';
        html_block += '</div></div></div>'
        return html_block;
    }



    function createSelectGroup(groupName, selectValues) {
        let html_block = '<div class="row"><div class="col-sm-4"><label>'+groupName+'</label></div><div class="col-sm-8"><select type="text" id="'+groupName+'" onchange="output_format(this.value)">';
        for (let selIndex in selectValues) {
            html_block += '<option>'+selectValues[selIndex]+'</option>';
        }
        html_block += '</select></div></div>';
        return html_block;
    }

    function createSelectGroupTrajectory(groupName, selectValues) {
        let html_block = '<div class="row"><div style="display: none" class="col-sm-4"><label>'+groupName+'</label></div><div style="display: none" class="col-sm-8"><select style="display: none" type="text" id="'+groupName+'">';
        for (let selIndex in selectValues) {
            html_block += '<option>'+selectValues[selIndex]+'</option>';
        }
        html_block += '</select></div></div>';
        return html_block;
    }

    function makeRequest() {
        httpRequest = new XMLHttpRequest();

        if (!httpRequest) {
            alert('Giving up :( Cannot create an XMLHTTP instance');
            return false;
        }
        httpRequest.onreadystatechange = capsContents;
        httpRequest.open('GET', location.pathname.replace(urlparts[urllen - 1],'').replace(urlparts[urllen - 2]+"//",'')+'?f=application/json');
        httpRequest.send();
        document.getElementById("loading_wheel").style.cssText = "display:inline;left:50%;top:50%;width:35px;height:35px;z-index:10000;position:absolute;";
    }


    function reload_page(traj_type_div) {
       drawnItems.clearLayers();
       capsContents();
       set_traj_div(traj_type_div);
    }
    function set_traj_div(traj_type_div){
       document.getElementById("trajectory type").value=traj_type_div;
    }


    function capsContents() {
        if (httpRequest.readyState === XMLHttpRequest.DONE) {
            if (httpRequest.status === 200) {
                let newHTML = createFormGroup('coords','coordinates','text',3,9,"coords");
                capsJSON = JSON.parse(httpRequest.responseText);
                document.getElementById('formlegend').innerText = urlparts[urllen-1] + " query";
                document.getElementById('col_title').innerText =  urlparts[urllen - 2] + " instance of " + "Collection: " + capsJSON['title'];
                form_block = document.getElementById('formfields')
                newHTML += '<div class="bordered" id="pnames" >';
                fp = ""
                for (let p in capsJSON.parameters) {
                    fp = p
                    newHTML += createFormGroup(p,p.replace("_"," "),"checkbox",8,4,"parameter-name");
                }
                newHTML += '</div>';
                if (window.location.href.indexOf("trajectory") > -1 || window.location.href.indexOf("corridor") > -1 ){
                   newHTML += '<div class="bordered" >';
                   newHTML += '<div class="row">Type:<div class="col-sm-4"></div>';
                   newHTML += '<div class="col-sm-8"><select type="text" id="trajectory type" onchange="reload_page(this.value)">';
                   newHTML += '<option>XY</option>';
                   newHTML += '<option>XYZ</option>';
                   newHTML += '<option>XYT</option>';
                   newHTML += '<option>XYZT</option>';
                   newHTML += '</select></div></div>'
                   newHTML += '</div>'
                   if (window.location.href.indexOf("corridor") > -1 ){
                      newHTML += '<br>'
                      newHTML += '<div class="col-sm-8">corridor-width<input type="text" id="corridor-width" value="100">';
                      newHTML += '</input> kilometers (default is 100 km)</div><br>'
                      newHTML += '<div class="col-sm-8">corridor-height (experimental)<input type="text" id="corridor-height" value="0"><br>';
                      newHTML += '</input>Number of fixed surfaces above/below</div><br>'
                      newHTML += '<div class="col-sm-8">resolution-x<input type="text" id="resolution-x" value="5">';
                      newHTML += '</input></div><br>'
                      newHTML += '<div class="col-sm-8">resolution-y (experimental)<input type="text" id="resolution-y" value="0">';
                      newHTML += '</input></div><br>'
                      newHTML += '<div class="col-sm-8">resolution-z<input type="text" id="resolution-z" value="">';
                      newHTML += '</input></div><br>'
                      //newHTML += '<div class="col-sm-8">corridor-height<select type="text" id="corridor-height" onchange="">';
                      //newHTML += '<option>1</option>';
                      //newHTML += '</select></div>'
                   }
                   if (capsJSON.parameters[fp].extent.temporal !== undefined) {
                       newHTML += '<div>Time Selection:    ';
                       let times_block = '';
                       var timeValues = capsJSON.parameters[fp].extent.temporal.range;
                       for (let timeIndex in timeValues) {
                          times_block += '<option>'+timeValues[timeIndex]+'</option>';
                       }
                       newHTML += '<select type="text" id="starttime">' + times_block + '</select>'
                       newHTML += '</div>';
                   }
                   newHTML += '<div style="display: none" class="row"><div class="col-sm-4"><label>crs</label></div>';
                   newHTML += '<div style="display: none" class="col-sm-8"><select type="text" id="crs">';
                   for (let crsIdx in capsJSON.crs) {
                       newHTML += '<option style="display: none">'+capsJSON.crs[crsIdx].id+'</option>';
                   }
                   newHTML += '</select></div></div>'
                   newHTML += createSelectGroup('f', [capsJSON.f[0],capsJSON.f[2]]);
                   if ((capsJSON.parameters[fp].extent.vertical !== undefined) && (capsJSON.parameters[fp].extent.vertical.range.length > 0)) {
                      newHTML += createSelectGroup('z-coord', capsJSON.parameters[fp].extent.vertical.range);
                   }
                   form_block.innerHTML = newHTML;
                } else {
                   if (capsJSON.parameters[fp].extent.temporal !== undefined) {
                      newHTML += '<div class="bordered" >';
                      newHTML += createTimeGroup(capsJSON.parameters[fp].extent.temporal.range);
                      newHTML += '</div>';

                   }
                   newHTML += '<div class="row"><div class="col-sm-4"><label>crs</label></div>';
                   newHTML += '<div class="col-sm-8"><select type="text" id="crs">';
                   for (let crsIdx in capsJSON.crs) {
                      newHTML += '<option>'+capsJSON.crs[crsIdx].id+'</option>';
                   }
                   newHTML += '</select></div></div>'
                   newHTML += createSelectGroup('f', capsJSON.f);
                   form_block.innerHTML = newHTML;
                }
          
                if ((capsJSON.parameters[fp].extent.vertical !== undefined) && (capsJSON.parameters[fp].extent.vertical.range.length > 0)) {
                    //if (window.location.href.indexOf("position") > -1 || window.location.href.indexOf("area") > -1){
                    //   newHTML += createSelectGroup('z-coord', capsJSON.parameters[fp].extent.vertical.range);
                    //}
                    if (window.location.href.indexOf("position") > -1 || window.location.href.indexOf("area") > -1 || window.location.href.indexOf("cube") > -1){
                       newHTML += createSelectGroup('z-coord1', capsJSON.parameters[fp].extent.vertical.range);
                       newHTML += createSelectGroup('z-coord2', capsJSON.parameters[fp].extent.vertical.range);
                    }
                    form_block.innerHTML = newHTML;
                }

                if (urlparts[urllen-1] == "position") {
                    if (capsJSON['point-query-options'] !== undefined) {
                        newHTML += createSelectGroup('interpolation', capsJSON['point-query-options']['interpolation']);
                    }
                } else if (urlparts[urllen-1] == "area" || urlparts[urllen-1] == "cube") {
                    if (capsJSON['polygon-query-options'] !== undefined) {
                        newHTML += createSelectGroup('interpolation-x', capsJSON['polygon-query-options']['interpolation-x']);
                        newHTML += createSelectGroup('interpolation-y', capsJSON['polygon-query-options']['interpolation-y']);
                    }
                }
                form_block.innerHTML = newHTML;
                document.getElementById("loading_wheel").style.cssText = "display:none;";    
            } else {
                document.getElementById("loading_wheel").style.cssText = "display:none;";
                alert('There was a problem with retrieving the metadata.');
            }
        }
    }
    makeRequest();
    function getPointQuery() {
        let port = location.port;
        if ( port.length > 0) {
           port = ":" + port;
        }

        document.getElementById("loading_wheel").style.cssText = "display:inline;left:50%;top:50%;width:35px;height:35px;z-index:10000;position:absolute;";
        removeLayers();  
        let query_url = location.pathname
        let valid_url = true;
        if ((document.getElementById('coords')!== null) && (document.getElementById('coords').value.length > 0)) {
            query_url +='?coords=' + document.getElementById('coords').value;
        } else {
            alert ("Please select a location (click marker icon on left handside of the map then click on your required location to generate the coordinates)");
            valid_url = false;
        }
        let paramOpts = document.getElementsByName("parameter-name");
        let parameterName = "";
        let delim = "";
        for (let p of paramOpts) {
            if (p.checked == true)
            {
                parameterName += delim + p.id;
                delim = ",";
            }
        }
        if (parameterName.length == 0 ) {
            valid_url = false;
            alert("Please select at least one parameter to query");
        } else {
            query_url += "&parameter-name="+ parameterName;
        }

        if (document.getElementById('starttime') !== null) {
            if (new Date(document.getElementById('starttime').value) > new Date(document.getElementById('endtime').value)) {
                alert("End date must be greater or equal to the Start date of the query");
                valid_url = false;
            } else if (document.getElementById('starttime').value == document.getElementById('endtime').value) {
                query_url += "&datetime=" + document.getElementById('starttime').value;
            } else {
                query_url += "&datetime=" + document.getElementById('starttime').value + "/" + document.getElementById('endtime').value;
            }
        }
        if (document.getElementById('z-coord') !== null ) {
            query_url += "&Z=" +  document.getElementById('z-coord').value;
        }
        if (document.getElementById('z-coord1') !== null && document.getElementById('z-coord2') !== null ) {
            query_url += "&Z=" +  document.getElementById('z-coord1').value + "/" + document.getElementById('z-coord2').value;
        }
        if (document.getElementById('crs').value.length > 0) {
            query_url += "&crs=" +  document.getElementById('crs').value;
        }

        if (document.getElementById('interpolation').value.length > 0) {
            query_url += "&interpolation=" +  document.getElementById('interpolation').value;
        }
        if (document.getElementById('f').value.length > 0) {
            query_url += "&f=" +  document.getElementById('f').value;
            if (document.getElementById('f').value != 'CoverageJSON'){
               document.getElementById("qurl").value = location.protocol + "//" + location.hostname + port + query_url;
               window.location.href=query_url;
               document.getElementById("loading_wheel").style.cssText = "display:none;";
               throw new Error(document.getElementById('f').value+' has successfully downloaded. Therefore, the javascript has aborted.');
            }
        }

        document.getElementById("qurl").value = location.protocol + "//" + location.hostname + port + query_url;
        if (valid_url) {        
            fetch(query_url)
            .then(function (response) {
                return response.json()
            }).then(function (output) {
                
                CovJSON.read(output).then(function (cov) {
                    document.getElementById("loading_wheel").style.cssText = "display:none;";                  
                    if (isTimeSeries(cov)) {
                        let popup = (new C.TimeSeriesPlot(cov)).setLatLng([cov._covjson.domain.axes.y.values[0], cov._covjson.domain.axes.x.values[0]]).openOn(map);
                    }
                    else {
                        console.log('Coverage loaded: ', cov)
                        document.getElementById("loading_wheel").style.cssText = "display:none;";
                        // add each parameter as a layer
                        let firstLayer;

                        let layerClazz = C.dataLayerClass(cov)

                        if (cov.coverages && !layerClazz) {
                            // generic collection
                            if (!cov.parameters) {
                                errmsg = "No data found"
                                throw new Error('Only coverage collections with a "parameters" property are supported')
                            }

                            for (let key of cov.parameters.keys()) {
                                let layers = cov.coverages
                                    .filter(coverage => coverage.parameters.has(key))
                                    .map(coverage => createLayer(coverage, { keys: [key] }))
                                layers.forEach(covlayer => map.fire('covlayercreate', { layer: covlayer }))
                                let layer = L.layerGroup(layers)
                                layersInControl.add(layer)

                                layerControl.addOverlay(layer, key)
                                if (!firstLayer) {
                                    firstLayer = layer

                                    // the following piece of code should be easier
                                    // TODO extend layer group class in leaflet-coverage (like PointCollection) to provide single 'add' event
                                    let addCount = 0
                                    for (let l of layers) {
                                        l.on('afterAdd', () => {
                                            coverageLayersOnMap.add(l)
                                            ++addCount
                                            if (addCount === layers.length) {
                                                // FIXME is this the right place?? define event semantics!
                                                map.fire('covlayeradd', { layer: l })
                                            }
                                        })
                                    }
                                }
                            }
                        } else if (layerClazz) {
                            // single coverage or a coverage collection of a specific domain type

                            for (let key of cov.parameters.keys()) {
                                let opts = { keys: [key] }
                                let layer = createLayer(cov, opts)
                                map.fire('covlayercreate', { layer })
                                layersInControl.add(layer)

                                layerControl.addOverlay(layer, key)
                                if (!firstLayer) {
                                    firstLayer = layer
                                    layer.on('afterAdd', () => {
                                        if (!cov.coverages) {
                                            if (isVerticalProfile(cov) || isTimeSeries(cov)) {
                                                layer.openPopup()
                                            }
                                        }
                                    })
                                }
                                layer.on('afterAdd', () => {
                                    coverageLayersOnMap.add(layer)
                                    map.fire('covlayeradd', { layer })
                                }).on('remove', () => {
                                    coverageLayersOnMap.delete(layer)
                                    map.fire('covlayerremove', { layer })
                                })
                            }
                        } else {
                            throw new Error('unsupported type')
                        }
                        try {
                            if (options.display && firstLayer) {
                            map.addLayer(firstLayer)
                        } 
                        }catch {

                        }
                       
                    }
                }).catch(function (e) {
                    // there was an error when loading the coverage
                    document.getElementById("loading_wheel").style.cssText = "display:none;";

                    alert('error loading data: ' + errmsg)
                    console.log(e)
                })
            }).catch(function (error) {
                document.getElementById("loading_wheel").style.cssText = "display:none;";
                alert('error loading data: ' + error.message)
                console.log('There has been a problem with your fetch operation: ', error.message);
            });
        }
        else {
            document.getElementById("loading_wheel").style.cssText = "display:none;";
        }        
    }



    function getPolygonQuery() {
        let port = location.port;
        if ( port.length > 0) {
           port = ":" + port;
        }

        removeLayers();   
        document.getElementById("loading_wheel").style.cssText = "display:inline;left:50%;top:50%;width:35px;height:35px;z-index:10000;position:absolute;";

        let query_url = location.pathname
        let valid_url = true;
        if ((document.getElementById('coords')!== null) && (document.getElementById('coords').value.length > 0)) {
            query_url +='?coords=' + document.getElementById('coords').value;
        } else {
            alert ("Please define the area (click polygon icon on left handside of the map then click on your required vertices to generate the coordinates)");
            valid_url = false;
        }
        let paramOpts = document.getElementsByName("parameter-name");
        let parameterName = "";
        let delim = "";
        for (let p of paramOpts) {
            if (p.checked == true)
            {
                parameterName += delim + p.id;
                delim = ",";
            }
        }
        if (parameterName.length == 0 ) {
            valid_url = false;
            alert("Please select at least one parameter to query");
        } else {
            query_url += "&parameter-name="+ parameterName;
        }

        if (document.getElementById('starttime') !== null) {
            if (new Date(document.getElementById('starttime').value) > new Date(document.getElementById('endtime').value)) {
                alert("End date must be greater or equal to the Start date of the query");
                valid_url = false;
            } else if (new Date(document.getElementById('starttime').value) == new Date(document.getElementById('endtime').value)) {
                query_url += "&datetime=" + document.getElementById('starttime').value;
            } else {
                query_url += "&datetime=" + document.getElementById('starttime').value + "/" + document.getElementById('endtime').value;
            }
        }
        if (document.getElementById('z-coord') !== null ) {
            query_url += "&Z=" +  document.getElementById('z-coord').value;
        }
        if (document.getElementById('z-coord1') !== null && document.getElementById('z-coord2') !== null ) {
            query_url += "&Z=" +  document.getElementById('z-coord1').value + "/" + document.getElementById('z-coord2').value;
        }

        if (document.getElementById('crs').value.length > 0) {
            query_url += "&crs=" +  document.getElementById('crs').value;
        }
        if (document.getElementById('interpolation-x').value.length > 0) {
            query_url += "&interpolation-x=" +  document.getElementById('interpolation-x').value;
        }
        if (document.getElementById('interpolation-y').value.length > 0) {
            query_url += "&interpolation-y=" +  document.getElementById('interpolation-y').value;
        }
        if (document.getElementById('f').value.length > 0) {
            let port = location.port;
            if ( port.length > 0) {
               port = ":" + port;
            }
            query_url += "&f=" +  document.getElementById('f').value;
            if (document.getElementById('f').value != 'CoverageJSON'){
               document.getElementById("qurl").value = location.protocol + "//" + location.hostname + port + query_url;
               location.href = query_url;
               document.getElementById("loading_wheel").style.cssText = "display:none;";
               alert(document.getElementById('f').value+' is downloading to your browser.');
               throw new Error(document.getElementById('f').value+' has successfully downloaded. Therefore, the javascript has aborted.');
            }
        }

        document.getElementById("qurl").value = location.protocol + "//" + location.hostname + port + query_url;

        if (valid_url) {        
            fetch(query_url)
                .then(function (response) {
                    return response.json()
                }).then(function (output) {
                    CovJSON.read(output).then(function (cov) {
                        options = {}
                        console.log('Coverage loaded: ', cov)
                        document.getElementById("loading_wheel").style.cssText = "display:none;";
                        // add each parameter as a layer
                        let firstLayer;

                        let layerClazz = C.dataLayerClass(cov)

                        if (cov.coverages && !layerClazz) {
                            // generic collection
                            if (!cov.parameters) {
                                errmsg = "No data found"
                                throw new Error('Only coverage collections with a "parameters" property are supported')
                            }

                            for (let key of cov.parameters.keys()) {
                                let layers = cov.coverages
                                    .filter(coverage => coverage.parameters.has(key))
                                    .map(coverage => createLayer(coverage, { keys: [key] }))
                                layers.forEach(covlayer => map.fire('covlayercreate', { layer: covlayer }))
                                let layer = L.layerGroup(layers)
                                layersInControl.add(layer)

                                layerControl.addOverlay(layer, key)
                                if (!firstLayer) {
                                    firstLayer = layer

                                    // the following piece of code should be easier
                                    // TODO extend layer group class in leaflet-coverage (like PointCollection) to provide single 'add' event
                                    let addCount = 0
                                    for (let l of layers) {
                                        l.on('afterAdd', () => {
                                            coverageLayersOnMap.add(l)
                                            ++addCount
                                            if (addCount === layers.length) {
                                                // FIXME is this the right place?? define event semantics!
                                                map.fire('covlayeradd', { layer: l })
                                            }
                                        })
                                    }
                                }
                            }
                        } else if (layerClazz) {
                            // single coverage or a coverage collection of a specific domain type

                            for (let key of cov.parameters.keys()) {
                                let opts = { keys: [key] }
                                let layer = createLayer(cov, opts)
                                map.fire('covlayercreate', { layer })
                                layersInControl.add(layer)

                                layerControl.addOverlay(layer, key)
                                if (!firstLayer) {
                                    firstLayer = layer
                                    layer.on('afterAdd', () => {
                                        if (!cov.coverages) {
                                            if (isVerticalProfile(cov) || isTimeSeries(cov)) {
                                                layer.openPopup()
                                            }
                                        }
                                    })
                                }
                                layer.on('afterAdd', () => {
                                    coverageLayersOnMap.add(layer)
                                    map.fire('covlayeradd', { layer })
                                }).on('remove', () => {
                                    coverageLayersOnMap.delete(layer)
                                    map.fire('covlayerremove', { layer })
                                })
                            }
                        } else {
                            throw new Error('unsupported type')
                        }
                        if (options.display && firstLayer) {
                            map.addLayer(firstLayer)
                        }
                    });
                }).catch(function (error) {
                    document.getElementById("loading_wheel").style.cssText = "display:none;";
                    alert('error loading data: ' + error.message)
                    console.log('There has been a problem with your fetch operation: ', error.message);
                });


        } 
        else {
            document.getElementById("loading_wheel").style.cssText = "display:none;";
        }        
    }


//Need to perform the trajectory query here:
//Start with the existion position code and modify that.

    function getTrajectoryQuery() {
        let port = location.port;
        if ( port.length > 0) {
            port = ":" + port;
        }
        document.getElementById("loading_wheel").style.cssText = "display:inline;left:50%;top:50%;width:35px;height:35px;z-index:10000;position:absolute;";
        removeLayers();  
        let query_url = location.pathname
        let valid_url = true;
        if ((document.getElementById('coords')!== null) && (document.getElementById('coords').value.length > 0)) {
            query_url +='?coords=' + document.getElementById('coords').value;
        } else {
            alert ("Please select a valid trajectory using the line selection in the toolbar)");
            valid_url = false;
        }
        let paramOpts = document.getElementsByName("parameter-name");
        let parameterName = "";
        let delim = "";
        for (let p of paramOpts) {
            if (p.checked == true)
            {
                parameterName += delim + p.id;
                delim = ",";
            }
        }
        if (parameterName.length == 0 ) {
            valid_url = false;
            alert("Please select at least one parameter to query");
        } else {
            query_url += "&parameter-name="+ parameterName;
        }

        if (document.getElementById('starttime') !== null && document.getElementById('endtime') !== null){
            if (new Date(document.getElementById('starttime').value) > new Date(document.getElementById('endtime').value)) {
                alert("End date must be greater or equal to the Start date of the query");
                valid_url = false;
            } else if (document.getElementById('starttime').value == document.getElementById('endtime').value) {
                query_url += "&datetime=" + document.getElementById('starttime').value;
            } else {
                query_url += "&datetime=" + document.getElementById('starttime').value + "/" + document.getElementById('endtime').value;
            }
        }

        //handle one time for the XY case of the trajectory
        if (document.getElementById('starttime') !== null && document.getElementById('endtime') == null){
           query_url += "&datetime=" + document.getElementById('starttime').value;
        }

        if (document.getElementById('z-coord') !== null ) {
            query_url += "&Z=" +  document.getElementById('z-coord').value;
        }
        if (document.getElementById('z-coord1') !== null && document.getElementById('z-coord2') !== null ) {
            query_url += "&Z=" +  document.getElementById('z-coord1').value + "/" + document.getElementById('z-coord2').value;
        }
        if (document.getElementById('crs').value.length > 0) {
            query_url += "&crs=" +  document.getElementById('crs').value;
        }

        //if (document.getElementById('interpolation').value.length > 0) {
        //    query_url += "&interpolation=" +  document.getElementById('interpolation').value;
        //}
        if (document.getElementById('f').value.length > 0) {
            query_url += "&f=" +  document.getElementById('f').value;
            if (document.getElementById('f').value != 'CoverageJSON'){
               document.getElementById("qurl").value = location.protocol + "//" + location.hostname + port + query_url;
               location.href = query_url;
               document.getElementById("loading_wheel").style.cssText = "display:none;";
               alert(document.getElementById('f').value+' is downloading to your browser.');
               throw new Error(document.getElementById('f').value+' has successfully downloaded. Therefore, the javascript has aborted.');
            }
        }

        document.getElementById("qurl").value = location.protocol + "//" + location.hostname + port + query_url;
        if (valid_url) {        
            fetch(query_url)
            .then(function (response) {
                return response.json()
            }).then(function (output) {
                
                CovJSON.read(output).then(function (cov) {
                    document.getElementById("loading_wheel").style.cssText = "display:none;";                  
                    if (isTimeSeries(cov)) {
                        let popup = (new C.TimeSeriesPlot(cov)).setLatLng([cov._covjson.domain.axes.y.values[0], cov._covjson.domain.axes.x.values[0]]).openOn(map);
                    }
                    else {
                        console.log('Coverage loaded: ', cov)
                        document.getElementById("loading_wheel").style.cssText = "display:none;";
                        // add each parameter as a layer
                        let firstLayer;

                        let layerClazz = C.dataLayerClass(cov)

                        if (cov.coverages && !layerClazz) {
                            // generic collection
                            if (!cov.parameters) {
                                errmsg = "No data found"
                                throw new Error('Only coverage collections with a "parameters" property are supported')
                            }

                            for (let key of cov.parameters.keys()) {
                                let layers = cov.coverages
                                    .filter(coverage => coverage.parameters.has(key))
                                    .map(coverage => createLayer(coverage, { keys: [key] }))
                                layers.forEach(covlayer => map.fire('covlayercreate', { layer: covlayer }))
                                let layer = L.layerGroup(layers)
                                layersInControl.add(layer)

                                layerControl.addOverlay(layer, key)
                                if (!firstLayer) {
                                    firstLayer = layer

                                    // the following piece of code should be easier
                                    // TODO extend layer group class in leaflet-coverage (like PointCollection) to provide single 'add' event
                                    let addCount = 0
                                    for (let l of layers) {
                                        l.on('afterAdd', () => {
                                            coverageLayersOnMap.add(l)
                                            ++addCount
                                            if (addCount === layers.length) {
                                                // FIXME is this the right place?? define event semantics!
                                                map.fire('covlayeradd', { layer: l })
                                            }
                                        })
                                    }
                                }
                            }
                        } else if (layerClazz) {
                            // single coverage or a coverage collection of a specific domain type

                            for (let key of cov.parameters.keys()) {
                                let opts = { keys: [key] }
                                let layer = createLayer(cov, opts)
                                map.fire('covlayercreate', { layer })
                                layersInControl.add(layer)

                                layerControl.addOverlay(layer, key)
                                if (!firstLayer) {
                                    firstLayer = layer
                                    layer.on('afterAdd', () => {
                                        if (!cov.coverages) {
                                            if (isVerticalProfile(cov) || isTimeSeries(cov)) {
                                                layer.openPopup()
                                            }
                                        }
                                    })
                                }
                                layer.on('afterAdd', () => {
                                    coverageLayersOnMap.add(layer)
                                    map.fire('covlayeradd', { layer })
                                }).on('remove', () => {
                                    coverageLayersOnMap.delete(layer)
                                    map.fire('covlayerremove', { layer })
                                })
                            }
                        } else {
                            throw new Error('unsupported type')
                        }
                        try {
                            if (options.display && firstLayer) {
                            map.addLayer(firstLayer)
                        } 
                        }catch {

                        }
                       
                    }
                }).catch(function (e) {
                    // there was an error when loading the coverage
                    document.getElementById("loading_wheel").style.cssText = "display:none;";

                    alert('error loading data: ' + errmsg)
                    console.log(e)
                })
            }).catch(function (error) {
                document.getElementById("loading_wheel").style.cssText = "display:none;";
                alert('error loading data: ' + error.message)
                console.log('There has been a problem with your fetch operation: ', error.message);
            });
        }
        else {
            document.getElementById("loading_wheel").style.cssText = "display:none;";
        }        
    }

//So that I don't mess up the functionality of Traj while developing Corridor, creating separate functions. May be able to combine these functions in the future.


    function getCorridorQuery() {
        let port = location.port;
        if ( port.length > 0) {
            port = ":" + port;
        }
        document.getElementById("loading_wheel").style.cssText = "display:inline;left:50%;top:50%;width:35px;height:35px;z-index:10000;position:absolute;";
        removeLayers();  
        let query_url = location.pathname
        let valid_url = true;
        if ((document.getElementById('coords')!== null) && (document.getElementById('coords').value.length > 0)) {
            query_url +='?coords=' + document.getElementById('coords').value;
        } else {
            alert ("Please select a valid trajectory using the line selection in the toolbar)");
            valid_url = false;
        }
        let paramOpts = document.getElementsByName("parameter-name");
        let parameterName = "";
        let delim = "";
        for (let p of paramOpts) {
            if (p.checked == true)
            {
                parameterName += delim + p.id;
                delim = ",";
            }
        }
        if (parameterName.length == 0 ) {
            valid_url = false;
            alert("Please select at least one parameter to query");
        } else {
            query_url += "&parameter-name="+ parameterName;
        }

        if (document.getElementById('starttime') !== null && document.getElementById('endtime') !== null){
            if (new Date(document.getElementById('starttime').value) > new Date(document.getElementById('endtime').value)) {
                alert("End date must be greater or equal to the Start date of the query");
                valid_url = false;
            } else if (document.getElementById('starttime').value == document.getElementById('endtime').value) {
                query_url += "&datetime=" + document.getElementById('starttime').value;
            } else {
                query_url += "&datetime=" + document.getElementById('starttime').value + "/" + document.getElementById('endtime').value;
            }
        }

        //handle one time for the XY case of the trajectory
        if (document.getElementById('starttime') !== null && document.getElementById('endtime') == null){
           query_url += "&datetime=" + document.getElementById('starttime').value;
        }

        if (document.getElementById('z-coord') !== null ) {
            query_url += "&Z=" +  document.getElementById('z-coord').value;
        }
        if (document.getElementById('z-coord1') !== null && document.getElementById('z-coord2') !== null ) {
            query_url += "&Z=" +  document.getElementById('z-coord1').value + "/" + document.getElementById('z-coord2').value;
        }
        if (document.getElementById('crs').value.length > 0) {
            query_url += "&crs=" +  document.getElementById('crs').value;
        }
        if (document.getElementById('resolution-x').value.length > 0) {
            query_url += "&resolution-x=" +  document.getElementById('resolution-x').value;
        }
        if (document.getElementById('resolution-y').value.length > 0) {
            query_url += "&resolution-y=" +  document.getElementById('resolution-y').value;
        }
        if (document.getElementById('resolution-z').value.length > 0) {
            query_url += "&resolution-z=" +  document.getElementById('resolution-z').value;
        }
        if (document.getElementById('corridor-width').value.length > 0) {
            query_url += "&corridor-width=" +  document.getElementById('corridor-width').value;
        }
        if (document.getElementById('crs').value.length > 0) {
            query_url += "&corridor-height=" +  document.getElementById('corridor-height').value;
        }

        //if (document.getElementById('interpolation').value.length > 0) {
        //    query_url += "&interpolation=" +  document.getElementById('interpolation').value;
        //}
        if (document.getElementById('f').value.length > 0) {
            query_url += "&f=" +  document.getElementById('f').value;
            if (document.getElementById('f').value != 'CoverageJSON'){
               document.getElementById("qurl").value = location.protocol + "//" + location.hostname + port + query_url;
               location.href = query_url;
               document.getElementById("loading_wheel").style.cssText = "display:none;";
               alert(document.getElementById('f').value+' is downloading to your browser.');
               throw new Error(document.getElementById('f').value+' has successfully downloaded. Therefore, the javascript has aborted.');
            }
        }

        document.getElementById("qurl").value = location.protocol + "//" + location.hostname + port + query_url;
        if (valid_url) {        
            fetch(query_url)
            .then(function (response) {
                return response.json()
            }).then(function (output) {
                
                CovJSON.read(output).then(function (cov) {
                    document.getElementById("loading_wheel").style.cssText = "display:none;";                  
                    if (isTimeSeries(cov)) {
                        let popup = (new C.TimeSeriesPlot(cov)).setLatLng([cov._covjson.domain.axes.y.values[0], cov._covjson.domain.axes.x.values[0]]).openOn(map);
                    }
                    else {
                        console.log('Coverage loaded: ', cov)
                        document.getElementById("loading_wheel").style.cssText = "display:none;";
                        // add each parameter as a layer
                        let firstLayer;

                        let layerClazz = C.dataLayerClass(cov)

                        if (cov.coverages && !layerClazz) {
                            // generic collection
                            if (!cov.parameters) {
                                errmsg = "No data found"
                                throw new Error('Only coverage collections with a "parameters" property are supported')
                            }

                            for (let key of cov.parameters.keys()) {
                                let layers = cov.coverages
                                    .filter(coverage => coverage.parameters.has(key))
                                    .map(coverage => createLayer(coverage, { keys: [key] }))
                                layers.forEach(covlayer => map.fire('covlayercreate', { layer: covlayer }))
                                let layer = L.layerGroup(layers)
                                layersInControl.add(layer)

                                layerControl.addOverlay(layer, key)
                                if (!firstLayer) {
                                    firstLayer = layer

                                    // the following piece of code should be easier
                                    // TODO extend layer group class in leaflet-coverage (like PointCollection) to provide single 'add' event
                                    let addCount = 0
                                    for (let l of layers) {
                                        l.on('afterAdd', () => {
                                            coverageLayersOnMap.add(l)
                                            ++addCount
                                            if (addCount === layers.length) {
                                                // FIXME is this the right place?? define event semantics!
                                                map.fire('covlayeradd', { layer: l })
                                            }
                                        })
                                    }
                                }
                            }
                        } else if (layerClazz) {
                            // single coverage or a coverage collection of a specific domain type

                            for (let key of cov.parameters.keys()) {
                                let opts = { keys: [key] }
                                let layer = createLayer(cov, opts)
                                map.fire('covlayercreate', { layer })
                                layersInControl.add(layer)

                                layerControl.addOverlay(layer, key)
                                if (!firstLayer) {
                                    firstLayer = layer
                                    layer.on('afterAdd', () => {
                                        if (!cov.coverages) {
                                            if (isVerticalProfile(cov) || isTimeSeries(cov)) {
                                                layer.openPopup()
                                            }
                                        }
                                    })
                                }
                                layer.on('afterAdd', () => {
                                    coverageLayersOnMap.add(layer)
                                    map.fire('covlayeradd', { layer })
                                }).on('remove', () => {
                                    coverageLayersOnMap.delete(layer)
                                    map.fire('covlayerremove', { layer })
                                })
                            }
                        } else {
                            throw new Error('unsupported type')
                        }
                        try {
                            if (options.display && firstLayer) {
                            map.addLayer(firstLayer)
                        } 
                        }catch {

                        }
                       
                    }
                }).catch(function (e) {
                    // there was an error when loading the coverage
                    document.getElementById("loading_wheel").style.cssText = "display:none;";

                    alert('error loading data: ' + errmsg)
                    console.log(e)
                })
            }).catch(function (error) {
                document.getElementById("loading_wheel").style.cssText = "display:none;";
                alert('error loading data: ' + error.message)
                console.log('There has been a problem with your fetch operation: ', error.message);
            });
        }
        else {
            document.getElementById("loading_wheel").style.cssText = "display:none;";
        }        
    }





//--------------------------------------------------------------------------------------------------------

    if (urlparts[urllen-3].toLowerCase().indexOf('uk') > -1) {
        map_center = [53.5, -2]
    } 

    if (urlparts[urllen-1] == 'position') {
        ispoint = true;
    }
    else if (urlparts[urllen-1] == 'area') {
        ispolygon = true;
    //    zoom_level = 4;
    }
    else if (urlparts[urllen-1] == 'cube') {
        iscube = true;
    //    zoom_level = 4;
    }
    else if (urlparts[urllen-1] == 'trajectory') {
        istrajectory = true;
    //    zoom_level = 4;
    }
    else if (urlparts[urllen-1] == 'corridor') {
        istrajectory = true;
    //    zoom_level = 4;
    }
    
//-----------------------Map initialization and base layers---------------------------
    let map = L.map('map', { center: map_center, zoom: zoom_level})
    console.log(document.getElementsByClassName('leaflet-control-zoom-in')[0])

    let layer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');
    let drawnItems = L.featureGroup().addTo(map);
    let wkt = new Wkt.Wkt();
    layer.id='OpenStreetMap';
    layer.addTo(map);
    drawnItems.addTo(map);
    map.addControl(new L.Control.Draw({
        draw: {
            circle: false,
            rectangle: iscube,
            polyline: istrajectory,
            circlemarker: false,
            marker: ispoint,
            polygon: ispolygon,
        },
        edit: {
            featureGroup: drawnItems,
            edit: false
        }
    }));




function add_country_borders(){
   let xhr = new XMLHttpRequest();
   xhr.open('GET', '/OGC-EDR-API/layers/country_borders.json');
   xhr.setRequestHeader('Content-Type', 'application/json');
   xhr.responseType = 'json';
   xhr.onload = function() {
      if (xhr.status !== 200) return
      layer_to_add=L.geoJSON(xhr.response,{
         style: {
            "color": "#000000",
            "stroke-width": 1,
            "fill-opacity": 0
         }
      }
      )
      layer_to_add.id="land_sea_borders";
      layer_to_add.addTo(map);
   };
   xhr.send();
}



//----------------------------------

    map.on(L.Draw.Event.DRAWSTART, function (event) {
        drawnItems.clearLayers();
    });
    let validQ = true;
    map.on(L.Draw.Event.CREATED, function (event) {
        let layer = event.layer;
        let type = event.layerType
        if (type === 'marker') {
            // Do marker specific actions
            layer.setLatLng(layer.getLatLng().wrap())
            coords = wkt.read(JSON.stringify(layer.toGeoJSON()));
            old_array=coords['components'][0]
            rounded_array=[]
            for (let i = 0; i < old_array.length; i++) {
               var x=Math.round(old_array[i]['x'],1);
               var y=Math.round(old_array[i]['y'],1);
               rounded_array[i]={};
               rounded_array[i]['x']=x;
               rounded_array[i]['y']=y;
            }
            coords['components'][0]=rounded_array;
        }
        else if (type === 'polygon') {
            removeLayers();            
            validQ = true;
            coords = wkt.read(JSON.stringify(wrapLatLons(layer).toGeoJSON()));
            old_array=coords['components'][0]
            rounded_array=[]
            for (let i = 0; i < old_array.length; i++) {
               var x=Math.round(old_array[i]['x'],1);
               var y=Math.round(old_array[i]['y'],1);
               rounded_array[i]={};
               rounded_array[i]['x']=x;
               rounded_array[i]['y']=y;
            }
            coords['components'][0]=rounded_array;		
            area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0])

            if ((area > 3100000000000) && ((urlparts[urllen - 3]).indexOf("global") > -1))  {
                alert("Sorry this the selected area is too large (this is to protect the third party datasource), please select an area of approximatley half the size of the US or less")
                validQ = false;
            }
            if ((area > 128000000000) && ((urlparts[urllen - 3]).indexOf("ukv") > -1))  {
                alert("Sorry this the selected area is too large (this is to protect the third party datasource), please select an area of approximatley half the size of the UK or less")
                validQ = false;
            }
            if ((area > 17000000) && ((urlparts[urllen - 3]).indexOf("osm") > -1))  {
                alert("Sorry this the selected area is too large (the generic nature of the client means is struggles to render large amounts of vector data), please select an area equivalent of a village or less")
                validQ = false;
            }
            if ((area > 930000000) && ((urlparts[urllen - 3]).indexOf("dem") > -1))  {
                alert("Sorry this the selected area is too large (this is to protect the third party datasource), please select an area of approximatley quarter a degree square or less")
                validQ = false;
            }            
        }
        else if (type === 'rectangle') {
           coords = wkt.read(JSON.stringify(wrapLatLons(layer).toGeoJSON()));
           old_array=coords['components'][0]
           rounded_array=[]
           for (let i = 0; i < old_array.length; i++) {
              var x=Math.round(old_array[i]['x'],1);
              var y=Math.round(old_array[i]['y'],1);
              rounded_array[i]={};
              rounded_array[i]['x']=x;
              rounded_array[i]['y']=y;
           }
           coords['components'][0]=rounded_array;		
           validQ=true;
        }
        if (validQ) {
            if (type === 'rectangle'){
               drawnItems.addLayer(layer);
               document.getElementById('coords').value = coords.write();
            }
            if (type === 'polyline'){
               drawnItems.addLayer(layer);
               var waypoint_count=drawnItems._layers[Object.keys(drawnItems._layers)[0]]._latlngs.length;
               var traj_type=document.getElementById("trajectory type").value;
               if (traj_type == 'XYT') {
                  var old_time_div=document.getElementById("starttime");
                  old_time_div.style.display="none";
                  form_block = document.getElementById('formfields');
                  var time_options='';
                  for (i = 1; i <= waypoint_count; i++) {
                     time_options += '<div class="row">Waypoint '+i+' Time:<div class="col-sm-4"></div>';
                     time_options += '<div class="col-sm-8"><select type="text" onchange="update_coords_traj(this)" id="wp_time_selection_'+i+'">';
                     //forecast times go here
                     var timeValues = capsJSON.parameters[fp].extent.temporal.range;
                     for (let timeIndex in timeValues) {
                        time_options += '<option>'+timeValues[timeIndex]+'</option>';
                     }
                     time_options += '</select></div></div>';
                     
                  }
                  var div = document.createElement("div");
                  div.innerHTML=time_options;
                  document.getElementById("formfields").appendChild(div);
                  childDiv = form_block.getElementsByTagName('div');
                  for (child in childDiv){
                     if (childDiv[child].innerHTML){
                        if (childDiv[child].innerHTML.includes('Time Selection')) {
                           childDiv[child].innerHTML='';
                        }
                     }
                  }
                  document.getElementById('time_storage').value=timeValues;
                  coords=toWKTTrajectory(layer,traj_type,timeValues,'');
                  document.getElementById('coords').value=coords;
               }
               if (traj_type == 'XYZ') {
                  var old_zedd_div=document.getElementById("z-coord");
                  old_zedd_div.style.display="none";
                  form_block = document.getElementById('formfields');

                  var zedd_options='';
                  for (i = 1; i <= waypoint_count; i++) {
                     zedd_options += '<div class="row">Waypoint '+i+' Zedd:<div class="col-sm-4"></div>';
                     zedd_options += '<div class="col-sm-8"><select type="text" onchange="update_coords_traj(this)" id="wp_zedd_selection_'+i+'">';
                     //forecast times go here
                     var zeddValues = capsJSON.parameters[fp].extent.vertical.range;
                     for (let zeddIndex in zeddValues) {
                        zedd_options += '<option>'+zeddValues[zeddIndex]+'</option>';
                     }
                     zedd_options += '</select></div></div>';

                  }
                  var div = document.createElement("div");
                  div.innerHTML=zedd_options;
                  document.getElementById("formfields").appendChild(div);
                  childDiv = form_block.getElementsByTagName('div');
                  for (child in childDiv){
                     if (childDiv[child].innerHTML){
                        if (childDiv[child].innerHTML.includes('Zedd Level Selection')) {
                           childDiv[child].innerHTML='';
                        }
                     }
                  }
                  document.getElementById('zedd_storage').value=zeddValues;
                  coords=toWKTTrajectory(layer,traj_type,'',zeddValues);
                  document.getElementById('coords').value=coords;
               }
               if (traj_type == 'XYZT') {
                  var old_zedd_div=document.getElementById("z-coord");
                  old_zedd_div.parentElement.value='datetime';
                  old_zedd_div.parentElement.innerHTML='datetime';
                  //old_zedd_div.style.display="none";
                  form_block = document.getElementById('formfields');
                  var zedd_options='';var time_options='';
                  for (i = 1; i <= waypoint_count; i++) {
                     zedd_options += '<div class="row">Waypoint '+i+' Zedd:<div class="col-sm-4"></div>';
                     zedd_options += '<div class="col-sm-8"><select type="text" onchange="update_coords_traj(this)" id="wp_zedd_selection_'+i+'">';
                     var zeddValues = capsJSON.parameters[fp].extent.vertical.range;
                     time_options += '<div class="row">Waypoint '+i+' Time:<div class="col-sm-4"></div>';
                     time_options += '<div class="col-sm-8"><select type="text" onchange="update_coords_traj(this)" id="wp_time_selection_'+i+'">';
                     var timeValues = capsJSON.parameters[fp].extent.temporal.range;
                     for (let zeddIndex in zeddValues) {
                        zedd_options += '<option>'+zeddValues[zeddIndex]+'</option>';
                     }
                     for (let timeIndex in timeValues) {
                        time_options += '<option>'+timeValues[timeIndex]+'</option>';
                     }
                     zedd_options += '</select></div></div>';
                     time_options += '</select></div></div>';
                  }
                  var d2container = document.createElement("div");
                  d2container.id="d2container";
                  d2container.style="display: flex;";
                  d2container.label="datetime";
                  document.getElementById("formfields").appendChild(d2container);                  
                  var div_z = document.createElement("div");
                  div_z.innerHTML=zedd_options;
                  div_z.style="width: 100%;";
                  document.getElementById("d2container").appendChild(div_z);
                  childDiv_z = form_block.getElementsByTagName('div');
                  for (child_z in childDiv_z){
                     if (childDiv_z[child_z].innerHTML){
                        if (childDiv_z[child_z].innerHTML.includes('Zedd Level Selection')) {
                           childDiv_z[child_z].innerHTML='';
                        }
                     }
                  }

                  var div_t = document.createElement("div");
                  div_t.innerHTML=time_options;
                  div_t.style="flex-grow 1; margin-left:30px; width: 100%";
                  document.getElementById("d2container").appendChild(div_t);
                  childDiv_t = form_block.getElementsByTagName('div');
                  for (child_t in childDiv_t){
                     if (childDiv_t[child_t].innerHTML){
                        if (childDiv_t[child_t].innerHTML.includes('Time Selection')) {
                           childDiv_t[child_t].innerHTML='';
                        }
                     }
                  }

                  document.getElementById('zedd_storage').value=zeddValues;
                  document.getElementById('time_storage').value=timeValues;
                  coords=toWKTTrajectory(layer,traj_type,timeValues,zeddValues);
                  document.getElementById('coords').value=coords;
               }

               else{
                  coords=toWKTTrajectory(layer,traj_type,'','');
                  document.getElementById('coords').value=coords;
               }
            }
            else{
               document.getElementById('coords').value = coords.write();
               drawnItems.addLayer(layer);
            }
        }
    });

function update_coords_traj(thisobject){
   console.log(thisobject.id);
   var replacement_value=thisobject.value;
   if (thisobject.id.includes('wp_time')){
      var child_object =  thisobject.childNodes;
      var value_check = 0
      var child_array=[];
      for (c = 0; c < child_object.length; c++){
         var option=child_object[c];
         if (child_object[c].value.includes(replacement_value)){
            value_check=1
         }
         if (value_check==1){
            child_array.push(child_object[c].value);
         }
      }
      var ref_id=thisobject.id.split('_')[3];
      let wp_divs = document.querySelectorAll('[id^="wp_time"]');
      for (w = 0; w < wp_divs.length; w++){
         wp_div_id=wp_divs[w].id.split('_')[3];
         if (wp_div_id > ref_id){
            var wp=document.getElementById(wp_divs[w].id);
            //clear options
            document.getElementById(wp_divs[w].id).innerHTML='';
            //add new options
            for (d = 0; d < child_array.length; d++){
               var option = document.createElement("option");
               option.text=child_array[d];
               option.value=child_array[d];
               wp.add(option);
            }     
            
         }
      }
   }
   var index=parseInt(thisobject.id.split('_')[3])-1;
   var coordObj=document.getElementById("coords").value;
   if (coordObj.includes('LINESTRINGM')){
      coordObj=coordObj.replace('LINESTRINGM(','');
      coordObj=coordObj.replace(')','');
      coordObjList=coordObj.split(',')
      //coordObjList[index].split(' ')[2];
      update_array=[];
      for (i = 0; i < coordObjList.length; i++){
         if (i == index){
            replacement_string=coordObjList[i].split(' ')[0]+' '+coordObjList[i].split(' ')[1]+' '+replacement_value;
            update_array.push(replacement_string);
         }
         else{
            update_array.push(coordObjList[i])
         }
      }
      var final_string='LINESTRINGM(';
      for (j = 0; j < update_array.length; j++){
          final_string=final_string+update_array[j]+',';
      }
      final_string=final_string.slice(0,-1)+')';
      document.getElementById("coords").value=final_string;
   }
   var coord_obj_string=coordObj.split('(')[0]
   if (coordObj.includes('LINESTRINGZ') && coord_obj_string != 'LINESTRINGZM'){
      coordObj=coordObj.replace('LINESTRINGZ(','');
      coordObj=coordObj.replace(')','');
      coordObjList=coordObj.split(',')
      update_array=[];
      for (i = 0; i < coordObjList.length; i++){
         if (i == index){
            replacement_string=coordObjList[i].split(' ')[0]+' '+coordObjList[i].split(' ')[1]+' '+replacement_value;
            update_array.push(replacement_string);
         }
         else{
            update_array.push(coordObjList[i])
         }
      }
      var final_string='LINESTRINGZ(';
      for (j = 0; j < update_array.length; j++){
          final_string=final_string+update_array[j]+',';
      }
      final_string=final_string.slice(0,-1)+')';
      document.getElementById("coords").value=final_string;
   }
   if (coordObj.includes('LINESTRINGZM')){
      coordObj=coordObj.replace('LINESTRINGZM(','');
      coordObj=coordObj.replace(')','');
      coordObjList=coordObj.split(',')
      update_array=[];
      for (i = 0; i < coordObjList.length; i++){
         if (i == index){
            if (replacement_value.includes('-') && replacement_value.includes('T')){
               replacement_string=coordObjList[i].split(' ')[0]+' '+coordObjList[i].split(' ')[1]+' '+coordObjList[i].split(' ')[2]+' '+replacement_value;
               update_array.push(replacement_string);
            }
            else {
               replacement_string=coordObjList[i].split(' ')[0]+' '+coordObjList[i].split(' ')[1]+' '+replacement_value+' '+coordObjList[i].split(' ')[3];
               update_array.push(replacement_string);
            }
         }
         else{
            update_array.push(coordObjList[i])
         }
      }
      var final_string='LINESTRINGZM(';
      for (j = 0; j < update_array.length; j++){
          final_string=final_string+update_array[j]+',';
      }
      final_string=final_string.slice(0,-1)+')';
      document.getElementById("coords").value=final_string;
   }

}


//Translation to wkt (thanks to https://gist.github.com/bmcbride/4248238)

function toWKTTrajectory(layer,traj_type,timeValues,zeddValues){
   //Time will default to first available time and we will create an event to update the
   //wkt definition if the dropdown is selected 
   var lng, lat, coords_test = [];
   if (layer instanceof L.Polygon || layer instanceof L.Polyline) {
      var latlngs = layer.getLatLngs();
      for (var i = 0; i < latlngs.length; i++) {
         var latlngs1 = latlngs[i];
         if (latlngs1.length){
            for (var j = 0; j < latlngs1.length; j++) {
               coords_test.push(latlngs1[j].lng + " " + latlngs1[j].lat);
               if (j === 0) {
                  lng = latlngs1[j].lng;
                  lat = latlngs1[j].lat;
               }
            }
         } 
         else {
               coords_test.push(latlngs[i].lng + " " + latlngs[i].lat);
                  if (i === 0) {
                     lng = latlngs[i].lng;
                     lat = latlngs[i].lat;
                  }
         }
      }
      if (traj_type == 'XY') {
         return "LINESTRING(" + coords_test.join(",") + ")";;
      }
      if (traj_type == 'XYT') {
         var i;
         var initial_time=document.getElementById('time_storage').value[0];
         for (i = 0; i < coords_test.length; i++) {
            coords_test[i]=coords_test[i]+' '+initial_time;
         }
         return "LINESTRINGM(" + coords_test.join(",") + ")";;
      }
      if (traj_type == 'XYZ') {
         var i;
         var initial_zedd=document.getElementById('zedd_storage').value[0];
         for (i = 0; i < coords_test.length; i++) {
            coords_test[i]=coords_test[i]+' '+initial_zedd;
         }
         return "LINESTRINGZ(" + coords_test.join(",") + ")";;
      }
      if (traj_type == 'XYZT') {
         var i;
         var initial_zedd=document.getElementById('zedd_storage').value[0];
         var initial_time=document.getElementById('time_storage').value[0];
         for (i = 0; i < coords_test.length; i++) {
            coords_test[i]=coords_test[i]+' '+initial_zedd +' '+ initial_time;
         }
         return "LINESTRINGZM(" + coords_test.join(",") + ")";;
      }

   }
}


   

function toWKT (layer) {
       var lng, lat, coords = [];
		if (layer instanceof L.Polygon || layer instanceof L.Polyline) {
			var latlngs = layer.getLatLngs();
		for (var i = 0; i < latlngs.length; i++) {
				var latlngs1 = latlngs[i];
				if (latlngs1.length){
				for (var j = 0; j < latlngs1.length; j++) {
					coords.push(latlngs1[j].lng + " " + latlngs1[j].lat);
					if (j === 0) {
						lng = latlngs1[j].lng;
						lat = latlngs1[j].lat;
					}
				}}
				else
				{
					coords.push(latlngs[i].lng + " " + latlngs[i].lat);
					if (i === 0) {
						lng = latlngs[i].lng;
						lat = latlngs[i].lat;
					}}
		};
			if (layer instanceof L.Polygon) {
				return "POLYGON((" + coords.join(",") + "," + lng + " " + lat + "))";
			}
		} else if (layer instanceof L.Marker) {
			return "POINT(" + layer.getLatLng().lng + " " + layer.getLatLng().lat + ")";
		}
	};



    let layerControl = L.control.layers([], [], { collapsed: false }).addTo(map)

    // We use ParameterSync here so that multiple coverage layers that display the same
    // parameter get synchronized in terms of their palette and extent.
    // It also allows us to display a single legend only.
    // Layers that don't have a single parameter get ignored automatically.
    var palette=(p1, p2) => p1;
    let paramSync = new C.ParameterSync({
        syncProperties: {
            palette: palette,
            paletteExtent: (e1, e2) => e1 && e2 ? [Math.min(e1[0], e2[0]), Math.max(e1[1], e2[1])] : null
        }
    }).on('parameterAdd', e => {
        // The virtual sync layer proxies the synced palette, paletteExtent, and parameter.
        // The sync layer will fire a 'remove' event if all real layers for that parameter were removed.
        let layer = e.syncLayer
        if (layer.palette) {
            C.legend(layer, {
                position: 'bottomright'
            }).addTo(map)
        }
    })

    let layersInControl = new Set()
    let coverageLayersOnMap = new Set()

    function removeLayers() {
        for (let layer of layersInControl) {
            layerControl.removeLayer(layer)
            if (map.hasLayer(layer)) {
                // FIXME leaflet's internal state breaks if layers or controls throw exceptions in onAdd()
                // -> could be prevented by linting CovJSON before-hand
                try {
                    map.removeLayer(layer)
                } catch (e) { }
            }

        }
        layersInControl = new Set();
        var layers_dict=map['_layers'];
        for (var layer_key in layers_dict) {
           selected_layer=layers_dict[layer_key];
           if ('_rings' in selected_layer){
              console.log('pick worked');
              selected_layer.remove();
           }

        }
    }

    // Wire up coverage value popup
    let valuePopup = new C.DraggableValuePopup({
    className: 'leaflet-popup-draggable',
    layers: [...coverageLayersOnMap]
    })
    function zoomToLayers(layers) {
        let bnds = layers.map(l => l.getBounds())
        let lproj = layers.map(l => l.domain.referencing[0].system.id)
        let bounds;
        if (lproj[0].indexOf("EPSG/0/4326") > -1)
        {
            bounds = L.latLngBounds([L.latLng(bnds[0].getWest(),bnds[0].getSouth()),L.latLng(bnds[0].getEast(),bnds[0].getNorth())])
        }
        else {
            bounds = L.latLngBounds(bnds)
        }
        let opts;
        if (bounds.getWest() === bounds.getEast() && bounds.getSouth() === bounds.getNorth()) {
            opts = { maxZoom: 5 }
        }
        map.fitBounds(bounds, opts)
    }

    function isVerticalProfile(cov) {
        return cov.domainType === C.COVJSON_VERTICALPROFILE
    }

    function isTimeSeries(cov) {
        return cov.domainType === C.COVJSON_POINTSERIES || cov.domainType === C.COVJSON_POLYGONSERIES
    }

    function createLayer(cov, opts) {
        let layer = C.dataLayer(cov, opts).on('afterAdd', e => {
            let covLayer = e.target
            console.log('layer added:', covLayer)

            // This registers the layer with the sync manager.
            // By doing that, the palette and extent get unified (if existing)
            // and an event gets fired if a new parameter was added.
            // See the code above where ParameterSync gets instantiated.
            paramSync.addLayer(covLayer)

            if (!cov.coverages) {
                if (covLayer.time) {
                    new C.TimeAxis(covLayer).addTo(map)
                }
                if (covLayer.vertical) {
                    new C.VerticalAxis(covLayer).addTo(map)
                }
            }
        }).on('dataLoad', () => map.fire('dataload'))
            .on('dataLoading', () => map.fire('dataloading'))
        layer.on('axisChange', () => {
            layer.paletteExtent = 'subset'
        })

        if (cov.coverages) {
            if (isVerticalProfile(cov)) {
                layer.bindPopupEach(coverage => new C.VerticalProfilePlot(coverage))
            } else if (isTimeSeries(cov)) {
                layer.bindPopupEach(coverage => new C.TimeSeriesPlot(coverage))
            }
        } else {
            if (isVerticalProfile(cov)) {
                layer.bindPopup(new C.VerticalProfilePlot(cov))
            } else if (isTimeSeries(cov)) {
                layer.bindPopup(new C.TimeSeriesPlot(cov))
            }
        }
        layer.id='data_layer';
        return layer
    }

    function wrapLatLons(inLayer) {
        let lls = inLayer.getLatLngs()[0];
        for (lLoop=0; lLoop < lls.length; lLoop++)
        {
            lls[lLoop] = lls[lLoop].wrap();
        }
        return inLayer.setLatLngs([lls]);        
    }

    // click event needed for Grid layer (can't use bindPopup there)
    map.on('doubleclick', e => {
    valuePopup.setLatLng(e.latlng).openOn(map)
    })
    map.on('covlayercreate', e => {
    // some layers already have a plot popup bound to it, ignore those
    if (!e.layer.getPopup()) {
        e.layer.bindPopup(valuePopup)
    }
    })
    map.on('covlayeradd', e => {
    valuePopup.addCoverageLayer(e.layer)
    })
    map.on('covlayerremove', e => {
    valuePopup.removeCoverageLayer(e.layer)
    })   


    function output_format(dropdown){
      if (dropdown != 'CoverageJSON'){
         document.getElementById('get_data').innerHTML="Show Data";
      }
      if (dropdown === 'CoverageJSON'){
         document.getElementById('get_data').innerHTML="Get Data";
      }
    }



//Color palette work

function linearPalette (colors, steps=256) {
  // draw the gradient in a canvas
  delete i;
  var canvas = document.createElement('canvas')
  canvas.width = steps
  canvas.height = 1
  var ctx = canvas.getContext('2d')
  var gradient = ctx.createLinearGradient(0, 0, steps - 1, 0)
  var num = colors.length
  for (var i = 0; i < num; i++) {
    try {
       gradient.addColorStop(i / (num - 1), colors[i]);    
    }
    catch(err) {
       console.log('end of color palette');
    }
  }
  ctx.fillStyle = gradient
  ctx.fillRect(0, 0, steps, 1)
 
  // now read back values into arrays
  var red = new Uint8Array(steps)
  var green = new Uint8Array(steps)
  var blue = new Uint8Array(steps)
 
  var pix = ctx.getImageData(0, 0, steps, 1).data
  for (let i = 0, j = 0; i < pix.length; i += 4, j++) {
    red[j] = pix[i]
    green[j] = pix[i + 1]
    blue[j] = pix[i + 2]
  }
 
  return {
    steps: red.length,
    red: red,
    green: green,
    blue: blue
  }
}

function set_palette(dvalue) {
   const request = new XMLHttpRequest();
   request.open('GET', '/OGC-EDR-API/static/color_palettes/'+dvalue+'.txt', true);
   request.onload = function() {
      if (request.status === 200) {
         var text=request.responseText;
         var color_array = text.split(/\n|\r/g);
         palette_new=linearPalette(color_array);
         var layers_dict=map['_layers'];
         console.log(layers_dict);
         for (var layer_key in layers_dict) {
            selected_layer=layers_dict[layer_key];
            map.removeLayer(selected_layer);
            for (var layer_attrs in selected_layer) {
               if (layer_attrs == '_palette') {
                  selected_layer[layer_attrs]=palette_new;
               }
            }
            selected_layer.addTo(map);
         }
      }
   }
   request.send();
}

   function palette_dropdown() {
         var request = new XMLHttpRequest();
         var pal_sel=document.getElementById("palette_vals");
         request.open('GET', '/OGC-EDR-API/palettes', true);
         request.onload = function() {
         if (request.status === 200) {
            const data = JSON.parse(request.responseText);
            for(let i = 0; i < data['palettes'].length; i++){
               var col_pal=data['palettes'][i].split('.')[0];
               var el = document.createElement("option");
               el.id=col_pal;
               //el.onclick="set_palette(this.value)"
               el.value=col_pal;
               el.textContent=col_pal;
               pal_sel.appendChild(el);
            }
          //pal_sel.style="display:block;";
          } else {
             console.log('failed');
             // Reached the server, but it returned an error
          }
         }
         request.send();
   }

palette_dropdown();



function unflattenArray(arr, dim) {
  let elemIndex = 0;

  if (!dim || !arr) return [];

  function _nest(dimIndex) {
    let result = [];

    if (dimIndex === dim.length - 1) {
      result = result.concat(arr.slice(elemIndex, elemIndex + dim[dimIndex]));
      elemIndex += dim[dimIndex];
    } else {
      for (let i = 0; i < dim[dimIndex]; i++) {
        result.push(_nest(dimIndex + 1));
      }
    }

    return result;
  }
  return _nest(0);
}



function contourAction(){
   var number_contours=prompt("Enter the number of contours","5");
   var layers_dict=map['_layers'];
   for (var layer_key in layers_dict) {
      selected_layer=layers_dict[layer_key];
      if ('_rings' in selected_layer){
         selected_layer.remove();
      }
      if ('_cov' in selected_layer){
         if (selected_layer['_cov']['type']=='Coverage'){
            var nd_dv_shape=selected_layer['_cov']['_covjson']['ranges'][Object.keys(selected_layer['_cov']['_covjson']['ranges'])[0]]['shape'];
            t_z_dim_array=[]
            for (const [key, value] of nd_dv_shape.entries()) {
               console.log(key, value);
               if ((key=='t')&&(value>1)){
                  t_z_dim_array.push(key);
               }
               if ((key=='z')&&(value>1)){
                  t_z_dim_array.push(key);
               } 

            }
            console.log('shane-test');
            console.log(t_z_dim_array);
            var data_values=selected_layer['_cov']['_covjson']['ranges'][Object.keys(selected_layer['_cov']['_covjson']['ranges'])[0]]['values'];
            var max_value=selected_layer['_cov']['_covjson']['ranges'][Object.keys(selected_layer['_cov']['_covjson']['ranges'])[0]]['actualMax'];
            var min_value=selected_layer['_cov']['_covjson']['ranges'][Object.keys(selected_layer['_cov']['_covjson']['ranges'])[0]]['actualMin'];
            interval_iterator=(max_value-min_value)/(number_contours-1);
            var new_value=min_value;
            interval=[];
            for (let i = min_value; i <= max_value; i += interval_iterator) {
               val=i.toFixed(2);
               interval.push(val);
            }
            var x_values=selected_layer['_cov']['_covjson']['domain']['axes'].get('x')['values'];
            var y_values=selected_layer['_cov']['_covjson']['domain']['axes'].get('y')['values'];
            x_size=selected_layer['_cov']['_covjson']['ranges'][Object.keys(selected_layer['_cov']['_covjson']['ranges'])[0]]['shape'].get('x');
            y_size=selected_layer['_cov']['_covjson']['ranges'][Object.keys(selected_layer['_cov']['_covjson']['ranges'])[0]]['shape'].get('y');
            x1=selected_layer['_cov']['_covjson']['domain']['axes'].get('x').values[0];
            y1=selected_layer['_cov']['_covjson']['domain']['axes'].get('y').values[0];
            top_right=[x1,y1];
            xlast_index=selected_layer['_cov']['_covjson']['domain']['axes'].get('x').values.length-1;
            ylast_index=selected_layer['_cov']['_covjson']['domain']['axes'].get('y').values.length-1;
            xlast=selected_layer['_cov']['_covjson']['domain']['axes'].get('x').values[xlast_index];
            ylast=selected_layer['_cov']['_covjson']['domain']['axes'].get('y').values[ylast_index];
            bottom_left=[xlast,ylast];
            new_bounds =[top_right,bottom_left];
            const contours = d3.contours()
               .size([x_size, y_size])
               .thresholds(interval)
               .smooth(true)
               (data_values).map(invert);            
            var myStyle = {
               "color": "#000000",
               "weight": 2,
               "fillOpacity": 0
            };
            L.geoJSON(contours,{style: myStyle}).addTo(map);
         }
      }
   }
}



// Invert the pixel coordinates to [longitude, latitude]. This assumes the
  // source GeoTIFF is in equirectangular coordinates.
  //
  // Note that inverting the projection breaks the polygon ring associations:
  // holes are no longer inside their exterior rings. Fortunately, since the
  // winding order of the rings is consistent and we’re now in spherical
  // coordinates, we can just merge everything into a single polygon!
  function invert(d) {
    var shared = {};
    var n = x_size;
    var m = y_size;
    var p = {
      type: "Polygon",
      coordinates: d3.merge(d.coordinates.map(function(polygon) {
        return polygon.map(function(ring) {
          return ring.map(function(point) {
            return [x1+point[0], y1-point[1]];
          }).reverse();
        });
      }))
    };


    p = d3.geoStitch(p);

    // If the MultiPolygon is empty, treat it as the Sphere.
    return p.coordinates.length
        ? {type: "Polygon", coordinates: p.coordinates, value: d.value}
        : {type: "Sphere", value: d.value};
  }

 
</script>
<div id='zedd_storage' style='display: none;'></div>
<div id='time_storage' style='display: none;'></div>
</html>
